{{toc}}
!結果
//!!開発の結果
!!コマンド名の検討
!!!コマンドの命名原則
機能ごとの動作はコマンドのオプションによって指定されます．
このオプションにどのような名前をつけるかは，どれだけコマンドを覚えやすいかという
意味で重要です．コマンドの振る舞いを的確に表す名称をつける必要があります．

この振る舞いとしてもっとも受け入れやすいのがshellで用意されているコマンドです．
pwd, ls, rm, touch, openなどはもっとも直感的に動作がわかるコマンドです．
hikiutilsの振る舞いを予測できるシェルコマンドと同じ名前でオプションを提供する
ようにします．


!!!hikiutilsがあらかじめ想定している利用形態
ここでhikiutilsがあらかじめ想定している利用形態を解説しておきます．
!!!!caption:hikiutilsがあらかじめ想定している利用形態
{{attach_view(hikiutils_yamane.007.jpeg,hikiutils_yamane)}}
hikiutilsはlocal PCとglobal serverとが用意されており，それらのデータをrsyncで
同期することで動作することを想定しています．これは，ネットに繋がっていないオフラインの状況でも
テキストなどの編集ができ，さらに不用意な書き換えを防ぐための機構です．さらに，
どちらもがバックアップともなっています．

これらの設定は，~/.hikircにyaml形式で保存されています．
<<< yaml
bob% cat ~/.hikirc
:srcs:
- :nick_name: new_ist
  :local_dir: "/Users/bob/Sites/new_ist_data/ist_data"
  :local_uri: http://localhost/ist
  :global_dir: nishitani@ist.ksc.kwansei.ac.jp:/home/nishitani/new_ist_data/ist_data
  :global_uri: http://ist.ksc.kwansei.ac.jp/~nishitani/
- :nick_name: dmz0
  :local_dir: "/Users/bob/Sites/nishitani0/Internal/data"
  :local_uri: http://localhost/~bob/nishitani0/Internal
  :global_dir: bob@dmz0:/Users/bob/Sites/nishitani0/Internal/data
  :global_uri: http://nishitani0.kwansei.ac.jp/~bob/nishitani0/Internal
>>>
また，一般的に一人のユーザがいくつものまとまりとしてのlocal-globalペアを
保持して管理することが普通です．それぞれにnicke_nameをつけて管理しています．
<<< bash
bob% hiki -s
hikiutils: provide utilities for helping hiki editing.
"open -a mi"
target_no:1
editor_command:open -a mi
 id | name      | local directory                               | global uri     
---------------------------------------------------------------------------------
  0 | new_ist   | /Users/bob/Sites/new_ist_data/ist_data        | http://ist.ksc.k
 *1 | dmz0      | /Users/bob/Sites/nishitani0/Internal/data     | http://nishitani
  2 | ist       | /Users/bob/Sites/hiki-data/data               | http://ist.ksc.k
  3 | new_maple | /Users/bob/Sites/new_ist_data/maple_hiki_data | http://ist.ksc.k
>>>
とすると，それらの一覧と，いまtargetにしているnick_nameディレクリが表示されます．

!!!コメンド名と振る舞いの詳細
開発の結果コマンドを以下のように書き換えました．
上部に記した，特によく使うコマンドに関しては，shellでよく使われるコマンド名と一致するにようにしました．

||変更前||変更後||動作の解説
||edit FILE       ||open|| open file
||list [FILE]     ||ls|| list files
||rsync           ||rsync|| rsync files
||update FILE     ||touch|| update file
||show            ||pwd||  show nick_names
||target VAL      ||cd||  targetを変える，change directoryとのメタファ
|| || ||
||move [FILE]     ||mv||  move file
||remove [FILE]   ||rm||  remove files
||add             || ||  add sources info
||checkdb         || ||  check database file
||datebase FILE   || ||  read datebase file
||display FILE    ||||  display converted hikifile
||euc FILE        || ||  translate file to euc
||help [COMMAND]  || ||  Describe available commands or one specific command
||version         || ||  show program version
それぞれの意図を動作の解説として記述しています．
!!!! open FILE
ファイルを編集のためにeditorでopen．Editorは~/.hikircに
 :editor_command: open -a mi
として保存されている．open -a miをemacsなどに適宜変更して使用．

!!!! ls [FILE]
local_dirにあるファイル名を[FILE*]として表示．例えば，hikiutils_yamane以下の拡張子が
ついたファイルを表示．hikiシステムではtextディレクトリーは階層構造を取ることができない．
西谷研ではdirectoryの代わりにスネーク表記で階層構造を表している．

!!!! rsync
local_dirの内容をglobal_dirにrsyncする．逆方向は同期に誤差が生じたり，permissionが
おかしくなるので，現在のところ一方向の同期のみとしている．したがって，作業手順としては
テキストの変更はlocal_dirで飲み行うようにしている．

!!!! touch FILE
loccal_dirで書き換えたFILEの内容をlocal_uriに反映させ，ブラウザで表示．シェルコマンドの
touchによって，変更時間を現在に変え，最新状態とするのに似せてコマンド名をtouchとしている．

!!!! pwd
nick_nameの一覧とtargetを表示，current targetをcurrent dirとみなして，
コマンド名をpwdとした．

!!!! cd VAL
targetを変える，change directoryとのメタファ．ただし，いまのところnick_nameでは
対応しておらず，nick_nameの番号をVAL入力することで変更する．

!!thorとoptparseのコードの比較
hikiutilsのコマンドライン解析ツールをoptparseからthorに換えることでコマンドの書き換えを行うことができた．
また，プログラムのコードもoptparseよりthorのほうが短く書け，簡単にコマンドを作成することができた．
!!!Thorとは
Thorとは，コマンドラインツールの作成を支援するライブラリのことである．
gitやbundlerのようにサブコマンドを含むコマンドラインツールを簡単に作成することができる[4]．
!!!!Thorの基本的な流れ
#Thorを継承したクラスのパブリックメソッドがコマンドになる
#クラス.start(ARGV)でコマンドラインの処理をスタートする
という流れである[4].
!!!optparseとは
optparseモジュールとは，getoptよりも簡便で，柔軟性に富み，かつ強力なコマンドライン解析ライブラリである．
optparseでは，より宣言的なスタイルのコマンドライン解析手法，すなわちOptionParserのインスタンスでコマンドラインを解析するという手法をとっている．
これを使うと，GNU/POSIX構文でオプションを指定できるだけでなく，使用法やヘルプメッセージの生成も行える[5]．
!!!!optparseの基本的な流れ
#OptionParserオブジェクトoptを生成する
#オプションを取り扱うブロックをoptに登録する
#opt.parse(ARGV)でコマンドラインを実際にparseする
という流れである[6].
!!!コードの解説
!!!!Thorの定義                                                      
{{attach_view(hikiutils_yamane.003.jpg,hikiutils_yamane)}}
#Hikithor::CLI.start(ARGV)が呼ばれる
#initializeメソッドが呼ばれる
#これではThorのinitializeメソッドが呼ばれない
#superを書くことでThorのinitializeメソッドが呼ばれる
optparseではrequireでoptparseを呼ぶだけでいいが，ThorではrequireでThorを呼びCLIクラスで継承しinitializeメソッドにsuperを書くことでThorのinitializeを呼ぶ必要がある．
!!!!!実際のコード
<<< ruby
# -*- coding: utf-8 -*-                                                         
require 'thor'
require 'kconv'
require 'hikidoc'
require 'erb'
require "hikiutils/version"
require "hikiutils/tmarshal"
require "hikiutils/infodb"
require 'systemu'
require 'fileutils'
require 'yaml'
require 'pp'

module Hikithor

  DATA_FILE=File.join(ENV['HOME'],'.hikirc')
  attr_accessor :src, :target, :editor_command, :browser, :data_name, :l_dir

  class CLI < Thor
   def initialize(*args)
      super
      @data_name=['nick_name','local_dir','local_uri','global_dir','global_uri']
      data_path = File.join(ENV['HOME'], '.hikirc')
      DataFiles.prepare(data_path)

      file = File.open(DATA_FILE,'r')
      @src = YAML.load(file.read)
      file.close
      @target = @src[:target]
      @l_dir=@src[:srcs][@target][:local_dir]
      browser = @src[:browser]
      @browser = (browser==nil) ? 'firefox' : browser
      p editor_command = @src[:editor_command]
      @editor_command = (editor_command==nil) ? 'open -a mi' : editor_command
   end
>>>
!!!!hikiutilsの実行
*Thor
{{attach_view(hikiutils_yamane.004.jpg,hikiutils_yamane)}}{{br}}
#hiki_thorのHikithor::CLI.start(ARGV)でhikiutils_thor.rbのCLIクラスを呼ぶ{{br}}
#hikiutils_thor.rbのCLIクラスのメソッドを順に実行していく{{br}}
*optparse
{{attach_view(hikiutils_yamane.001.jpg,hikiutils_yamane)}}
#HikiのHikiUtils::Command.run(ARGV)でhikiutils.rbのrunメソッドを呼ぶ
#new(argv).executeでexecuteメソッドが実行される
このようにoptparseでは実行を行うためのメソッドが必要であるが，Thorではクラスのメソッドを順に実行していくため
runメソッドとexecuteメソッドは必要ない．
!!!!!実際のコード
*Thor
<<< ruby
#!/usr/bin/env ruby                                                             

require "hikiutils_thor"

Hikithor::CLI.start(ARGV)
>>>
<<< ruby
# -*- coding: utf-8 -*-                                                         
require 'thor'
require 'kconv'
require 'hikidoc'
require 'erb'
require "hikiutils/version"
require "hikiutils/tmarshal"
require "hikiutils/infodb"
require 'systemu'
require 'fileutils'
require 'yaml'
require 'pp'

module Hikithor

  DATA_FILE=File.join(ENV['HOME'],'.hikirc')
  attr_accessor :src, :target, :editor_command, :browser, :data_name, :l_dir

  class CLI < Thor
   def initialize(*args)
      super
      @data_name=['nick_name','local_dir','local_uri','global_dir','global_uri']
      data_path = File.join(ENV['HOME'], '.hikirc')
      DataFiles.prepare(data_path)

      file = File.open(DATA_FILE,'r')
      @src = YAML.load(file.read)
      file.close
      @target = @src[:target]
      @l_dir=@src[:srcs][@target][:local_dir]
      browser = @src[:browser]
      @browser = (browser==nil) ? 'firefox' : browser

>>>
*optparse
<<< ruby
#!/usr/bin/env ruby                                                             

require "hikiutils"

HikiUtils::Command.run(ARGV)
>>>
<<< ruby
    def self.run(argv=[])
      print "hikiutils: provide utilities for helping hiki editing.\n"
      new(argv).execute
    end

    def execute
      @argv << '--help' if @argv.size==0
      command_parser = OptionParser.new do |opt|
        opt.on('-v', '--version','show program Version.') { |v|
          opt.version = HikiUtils::VERSION
          puts opt.ver
        }
        opt.on('-s', '--show','show sources') {show_sources}
        opt.on('-a', '--add','add sources info') {add_sources }
        opt.on('-t', '--target VAL','set target id') {|val| set_target(val) }
        opt.on('-e', '--edit FILE','open file') {|file| edit_file(file) }
        opt.on('-l', '--list [FILE]','list files') {|file| list_files(file) }
        opt.on('-u', '--update FILE','update file') {|file| update_file(file) }
        opt.on('-r', '--rsync','rsync files') {rsync_files}
        opt.on('--database FILE','read database file') {|file| db_file(file)}
        opt.on('--display FILE','display converted hikifile') {|file| display(f\
ile)}
        opt.on('-c', '--checkdb','check database file') {check_db}
        opt.on('--remove FILE','remove file') {|file| remove_file(file)}
        opt.on('--move FILES','move file1,file2',Array) {|files| move_file(file\
s)}
        opt.on('--euc FILE','translate file to euc') {|file| euc_file(file) }
        opt.on('--initialize','initialize source directory') {dir_init() }
      end
      begin
        command_parser.parse!(@argv)
      rescue=> eval
        p eval
      end
      dump_sources
      exit
    end  
>>>
!!!!コマンドの表示と実行
*Thor
{{attach_view(hikiutils_yamane.002.jpg,hikiutils_yamane)}}
#コマンド名，コマンドの説明を一覧に表示させる
#パブリックメソッドのコマンドを別のコマンド名でも実行できるようにする
#コマンドの命令の実行コード
*optparse
{{attach_view(hikiutils_yamane.005.jpg,hikiutils_yamane)}}
よって，optparseではOptionParserオブジェクトoptを生成を行い，コマンドをoptに登録して一覧に表示するメソッドとそれぞれコマンドの実行処理が書かれたメソッドがあるが，
thorではそれぞれのdescで一覧を表示しmapとパブリックメソッドでコマンドの実行処理を行うためコードが短くなる．
!!!!!実際のコード
*Thor
<<< ruby
    desc 'show,--show', 'show sources'
    map "--show" => "show"
    def show
      printf("target_no:%i\n",@src[:target])
      printf("editor_command:%s\n",@src[:editor_command])
      @i_size,@n_size,@l_size,@g_size=3,5,30,15 #i,g_size are fixed             
      n_l,l_l=0,0
      @src[:srcs].each_with_index{|src,i|
        n_l =(n_l= src[:nick_name].length)>@n_size? n_l:@n_size
        l_l =(l_l= src[:local_dir].length)>@l_size? l_l:@l_size
      }
      @n_size,@l_size=n_l,l_l
      command = Command.new
      header = command.display_format('id','name','local directory','global uri',@i_size,@n_size,@l_size,@g_size)

      puts header
      puts '-' * header.size

      @src[:srcs].each_with_index{|src,i|
        target = i==@src[:target] ? '*':' '
        id = target+i.to_s
        name=src[:nick_name]
        local=src[:local_dir]
        global=src[:global_uri]
        puts command.display_format(id,name,local,global,@i_size,@n_size,@l_size,@g_size)
      }
    end
>>>
*optparse
<<< ruby 
    def execute
      @argv << '--help' if @argv.size==0
      command_parser = OptionParser.new do |opt|
        opt.on('-v', '--version','show program Version.') { |v|
          opt.version = HikiUtils::VERSION
          puts opt.ver
        }
        opt.on('-s', '--show','show sources') {show_sources}
        opt.on('-a', '--add','add sources info') {add_sources }
        opt.on('-t', '--target VAL','set target id') {|val| set_target(val)}
        opt.on('-e', '--edit FILE','open file') {|file| edit_file(file) }
        opt.on('-l', '--list [FILE]','list files') {|file| list_files(file)}
        opt.on('-u', '--update FILE','update file') {|file| update_file(file) }
        opt.on('-r', '--rsync','rsync files') {rsync_files}
        opt.on('--database FILE','read database file') {|file| db_file(file)}
        opt.on('--display FILE','display converted hikifile') {|file| display(file)}
        opt.on('-c', '--checkdb','check database file') {check_db}
        opt.on('--remove FILE','remove file') {|file| remove_file(file)}
        opt.on('--move FILES','move file1,file2',Array) {|files| move_file(files)}
        opt.on('--euc FILE','translate file to euc') {|file| euc_file(file)}
        opt.on('--initialize','initialize source directory') {dir_init() }
      end
      begin
        command_parser.parse!(@argv)
      rescue=> eval
        p eval
      end
      dump_sources
      exit
    end    
    
    def show_sources()
      printf("target_no:%i\n",@src[:target])
      printf("editor_command:%s\n",@src[:editor_command])
      check_display_size()
      header = display_format('id','name','local directory','global uri')

      puts header
      puts '-' * header.size

      @src[:srcs].each_with_index{|src,i|
        target = i==@src[:target] ? '*':' '
        id = target+i.to_s
        name=src[:nick_name]
        local=src[:local_dir]
        global=src[:global_uri]
        puts display_format(id,name,local,global)
      }
    end

    def add_sources
      cont = {}
      @data_name.each{|name|
        printf("%s ? ", name)
        tmp = gets.chomp
        cont[name.to_sym] = tmp
      }
      @src[:srcs] << cont
      show_sources
    end
>>>