
\section{CLIのコード}
hikiutilsのコマンドライン解析ツールをoptparseからthorに換えることでコマンドの書き換えを行うことができた．
また，thorで書かれたhikiutilsはoptparseで書かれたものよりもコードが短くなり，コマンドの解析も簡単に行えることができた．
ここではthorとoptparseのコードを比較しthorの良さを確認する．

\subsection{CLIの解説}
\subsubsection{Thor}
Thorとは，コマンドラインツールの作成を支援するライブラリのことである．
gitやbundlerのようにサブコマンドを含むコマンドラインツールを簡単に作成することができる[1-2]．

Thorの基本的な流れとしては

\begin{enumerate}
\item Thorを継承したクラスのパブリックメソッドがコマンドになる
\item クラス.start(ARGV)でコマンドラインの処理をスタートする
\end{enumerate}
という流れである[1-2].

startに渡す引数が空の場合，Thorはクラスのヘルプリストを出力する．
また，Thorはサブコマンドやサブサブコマンドも作ることができる．

\subsubsection{optparse}
optparseとは，getoptよりも簡便で，柔軟性に富み，かつ強力なコマンドライン解析ライブラリである．
optparseでは，より宣言的なスタイルのコマンドライン解析手法，すなわちOptionParserのインスタンスでコマンドラインを解析するという手法をとっている．
これを使うと，GNU/POSIX構文でオプションを指定できるだけでなく，使用法やヘルプメッセージの生成も行える[1-3]．

利用頻度はあまり高くないが古くから開発され，使用例が広く紹介されている．

optparseの基本的な流れとしては

\begin{enumerate}
\item OptionParserオブジェクトoptを生成する
\item オプションを取り扱うブロックをopt.onに登録する
\item opt.parse(ARGV)でコマンドラインを実際にparseする
\end{enumerate}
という流れである.

OptionParserはコマンドラインのオプション取り扱うためのクラスであるためオブジェクトoptを生成されopt.onにコマンドを登録することができる．
しかし，OptionParser\#onにはコマンドが登録されているだけであるため，OptionParser\#parseが呼ばれた時，コマンドラインにオプションが指定されていれば実行される．
optparseにはデフォルトとして--helpと--versionオプションを認識する[1-4].

