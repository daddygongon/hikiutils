!Thorによる実装
手法のところで概観した通り，thorを用いることで記述の簡略化が期待できる．ここでは，実際に書き換える前後，すなわちoptparse版とthor版の対応するコードを比較することで，以下の具体的な違い
*クラス初期化 
*コマンド定義
*CLIの実行プロセス
について詳しく検討を行う．

!!クラス初期化
 
!!!caption:Thorのinitializeでのコード
{{attach_view(hikiutils_yamane_09_copy.003.jpg,hikiutils_yamane)}}

Thorのinitializeでのコードはつぎの通りである．
#Hikithor::CLI.start(ARGV)が呼ばれる
#initializeメソッドが呼ばれる
#これではThorのinitializeメソッドが呼ばれない
#superを書くことでThorのinitializeメソッドが呼ばれる
optparseではrequireでoptparseを呼びoptparseのinitializeを定義する必要はないが，Thorはinitializeを定義する必要がある．Thorの定義方法はrequireでThorを呼びCLIクラスで継承し，initializeメソッドにsuperを書くことでThorのinitializeが呼ばれる．initializeメソッド内ではThorの初期設定がされていないため，スーパークラスのメソッドを読み出してくれるsuperを書き加えることで図のようにinitializeメソッド内でThorのinitilalizeメソッドが呼ばれ定義される．

<<< ruby

module Hikithor

  DATA_FILE=File.join(ENV['HOME'],'.hikirc')
  attr_accessor :src, :target, :editor_command, :browser, :data_name, :l_dir

  class CLI < Thor
   def initialize(*args)
      super
      @data_name=['nick_name','local_dir','local_uri','global_dir','global_uri']
      data_path = File.join(ENV['HOME'], '.hikirc')
      DataFiles.prepare(data_path)

      ...以下略...
   end
>>>

!!コマンド定義

!!!caption:thorにおけるコマンド記述のひな形．
{{attach_view(hikiutils_yamane_09_copy.004.jpg,hikiutils_yamane)}}

thorではoptparseのような登録処理はない．図にある通りにコマンドが記述され，それらは以下のように構成される．
#desc以降にコマンド名と，その説明が記述される．これらはコマンドhelpで一覧として表示させる
#mapによって別のコマンド名でも実行できるように定義される．
#defで定義されたメソッドの実行コード

Thorではdescで一覧を表示されるコマンド名，コマンドの説明を登録する．しかし，ここで記述したコマンドは単に一覧で表示させるためのものであり，実際に実行される時に呼び出すコマンド名は，defで定義された名前である．Thorでは処理実行を行うメソッド名がコマンド名となり，コマンド名１つが対応する．

これに別名を与えるために利用されるキーワードがmapである．
<<<
map A => B
>>>
mapとはBと呼ばれるメソッドをAでも呼べるようにしてくれるものである．
よって，これを使うことでコマンドの別名を指定することができる．

<<< ruby
    desc 'show,--show', 'show sources'
    map "--show" => "show"
    def show
      printf("target_no:%i\n",@src[:target])
      printf("editor_command:%s\n",@src[:editor_command])
      ,,,以下略...
    end
>>>

以上より，Thorではコマンドの指定と処理にはdesc,map,処理メソッドだけで済む．optparseではコマンドを登録するためのメソッドと処理メソッドの両方が必要になっていた．一方Thorでは，処理メソッドが直接コマンド名となるため記述が簡潔になる．

!!CLIの実行プロセス


!!!caption:CLIの実行プロセス．
{{attach_view(hikiutils_yamane_09_copy.006.jpg,hikiutils_yamane)}}

Thorにおけるcliの実行プロセスは次の通りである．
#hiki_thorのHikithor::CLI.start(ARGV)でhikiutils_thor.rbのCLIクラスを呼ぶ
#hikiutils_thor.rbのCLIクラスのメソッドを順に実行していく

Thorではstart(ARGV)を呼び出すことでCLIを開始する．Hikithor::CLI.start(ARGV)を実行されることによりrequireで呼ばれているhikiutils_thor.rbのCLIコマンドを順に実行する．そして，入力されたコマンドと一致するメソッドを探し，そのコマンドの処理が実行される．

<<< ruby
#!/usr/bin/env ruby                                                             

require "hikiutils_thor"

Hikithor::CLI.start(ARGV)
>>>

<<<

module Hikithor

  DATA_FILE=File.join(ENV['HOME'],'.hikirc')
  attr_accessor :src, :target, :editor_command, :browser, :data_name, :l_dir

  class CLI < Thor
   def initialize(*args)
      super
      @data_name=['nick_name','local_dir','local_uri','global_dir','global_uri']
      data_path = File.join(ENV['HOME'], '.hikirc')
      DataFiles.prepare(data_path)
      ...以下略...
>>>

Thorではクラスのメソッドを順に実行していくためrunメソッドとexecuteメソッドは必要ない．また，optparseでの実行手順はメソッドの移動回数が多く複雑であるが，Thorは単純で分かりやすいものとなっている．

!!optparseとの全体的な比較
コードからもThorのほうが短くなっていることが分かる．よって，Thorとoptparseでのコードの違いは以上の部分になるが全体的にもThorのほうがコードが短くなり，コマンドの定義も簡単に行うことができる．また，実行手順も分かりやすくコードが読みやすいため書き換えもすぐ行うことができるので，より直感的なコマンドを実装することも可能となった．